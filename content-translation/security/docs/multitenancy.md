# 租户隔离
当我们考虑到多租户时，我们通常希望将一个用户或应用程序与运行在共享基础架构上的其他用户或应用程序隔离. 

Kuberntes是一个 _单一的租户编排器_ ，即控制平面的单个实例在集群中的所有租户之间共享。 但是，您可以使用各种Kubernetes对象来创建多租户的外观。 例如，可以实现命名空间和基于角色的访问控制（RBAC），以在逻辑上将租户彼此隔离。 同样，配额和限制范围可用于控制每个租户可以消耗的群集资源量。 但是，群集是唯一提供强大安全边界的构造。 这是因为设法获得对群集内主机的访问权限的攻击者可以检索安装在该主机上的 _所有的_ Secrets，ConfigMap和Volumes。 他们还可以模拟Kubelet，这将允许他们操纵节点的属性和/或在集群内横向移动.

以下各节将说明如何实现租户隔离，同时减轻使用像Kubernetes这样的单个租户编排器的风险.

## 软多租户

通过软多租户，您可以使用本地Kubernetes构造，例如 名称空间，角色和角色绑定以及网络策略，以在租户之间创建逻辑隔离。 例如，RBAC可以阻止租户访问或操纵彼此的资源。 配额和限制范围控制每个租户可以消耗的群集资源的数量，而网络策略可以帮助防止部署到不同名称空间的应用程序彼此通信.

但是，这些控件都不能阻止来自不同租户的窗格共享一个节点。 如果需要更强的隔离性，则可以使用节点选择器，反亲和性规则和/或污点和容差来强制将来自不同租户的Pod调度到单独的节点上； 通常称为 _唯一租户节点_。 在有许多租户的环境中，这可能变得相当复杂且成本过高. 

!!! 注意
    使用名称空间实现的软多租户不允许您为租户提供名称空间的已过滤列表，因为名称空间是全局作用域类型。 如果租户有能力查看特定的命名空间，则可以查看集群中的所有命名空间. 

!!! 警告
    借助软多租户，租户保留了查询CoreDNS以获得默认情况下在群集内运行的所有服务的功能。 如果需要限制对记录的访问，请考虑对CoreDNS使用防火墙或策略插件。 有关更多信息，请参见 https://github.com/coredns/policy#kubernetes-metadata-multi-tenancy-policy. 

[Kiosk](https://github.com/kiosk-sh/kiosk) 是一个开源项目，可以帮助实现软多租户。 它被实现为一系列CRD和控制器，它们提供以下功能: 

  + **帐户和帐户用户** 在共享的Kubernetes集群中分隔租户
  + **自助式命名空间设置** 服务于帐户用户
  + **帐户限制** 以确保共享集群时的服务质量和公平性
  + **名称空间模板** 用于安全的租户隔离和自助式名称空间初始化
  
[Loft](https://loft.sh) 是Kiosk维护者的商业产品，它增加了以下功能: 

  + **配置多集群访问** 以授予对多个集群中空间的访问权限 
  + **睡眠模式** 在不活动期间缩小空间中的部署
  + **单点登录** 与GitHub等OIDC身份验证提供程序一起使用

可以通过软多租户解决三个主要用例.

### 企业环境

第一种是在企业环境中，"租户"是半信任的，因为它们是员工，承包商或组织的其他授权。 每个租户通常将与一个行政部门（例如部门或团队）保持一致。

在这种类型的设置中，群集管理员通常将负责创建名称空间和管理策略。 他们还可以实施委托管理模型，其中某些人可以监督名称空间，从而允许他们对与部署，服务，pod，作业等非策略相关的对象执行CRUD操作。

在此设置下，Docker提供的隔离可能是可接受的，或者可能需要通过其他控制（例如Pod安全策略（PSP））加以增强。 如果需要更严格的隔离，则可能有必要限制不同名称空间中服务之间的通信。

### Kubernetes即服务

相比之下，可以在要提供Kubernetes即服务（KaaS）的设置中使用软多租户。 使用KaaS，您的应用程序以及提供一组PaaS服务的一组控制器和CRD托管在共享群集中。 租户直接与Kubernetes API服务器进行交互，并被允许对非策略对象执行CRUD操作。 自助服务还有一个要素，就是可以允许租户创建和管理自己的命名空间。 在这种类型的环境中，假定租户正在运行不受信任的代码。

为了隔离这种类型的环境中的租户，您可能需要实施严格的网络策略以及 _pod沙盒_。 沙盒是您在Firecracker之类的微型VM或用户空间内核中运行pod容器的地方。 今天，您可以使用EKS Fargate创建沙盒pods.

### 软件即服务（SaaS）

软多租户的最终用例是在软件即服务（SaaS）设置中。 在这种环境中，每个租户都与在集群中运行的应用程序的特定 _实例_ 关联。 每个实例通常都有自己的数据，并使用通常独立于Kubernetes RBAC的单独访问控制。

与其他用例不同，SaaS设置中的租户不直接与Kubernetes API交互。 相反，SaaS应用程序负责与Kubernetes API交互以创建支持每个租户的必要对象。.

## Kubernetes构造

在每种情况下，以下构造都用于将租户彼此隔离: 

### Namespaces

命名空间是实现软多租户的基础。 它们使您可以将群集分为逻辑分区。 配额，网络策略，服务帐户和实现多租户所需的其他对象的作用域仅限于名称空间.

### Network policies

默认情况下，允许Kubernetes集群中的所有Pod相互通信。 可以使用网络策略来更改此行为。

网络策略使用标签或IP地址范围限制Pod之间的通信。 在需要在租户之间进行严格的网络隔离的多租户环境中，我们建议从一条默认规则开始，该规则拒绝Pod之间的通信，而另一条规则则允许所有Pod在DNS服务器上查询名称解析。 有了这个适当的位置，您就可以开始添加更多允许在名称空间内进行通信的宽松规则。 可以根据需要进一步完善. 

!!! 注意 
    网络策略是必要的，但还不够。 网络策略的实施需要诸如Calico vs Cilium之类的策略引擎.

### 基于角色的访问控制（RBAC）

角色和角色绑定是Kubernetes对象，用于在Kubernetes中实施基于角色的访问控制（RBAC）。 **角色**包含可以对集群中的对象执行的操作的列表。 **角色绑定**指定角色适用的个人或群体。 在企业和KaaS设置中，RBAC可用于允许选定的组或个人管理对象。

### 配额

配额用于定义对群集中托管的工作负载的限制。 使用配额，您可以指定Pod可以使用的最大CPU和内存量，或者可以限制可以在群集或命名空间中分配的资源数量。 **限制范围**允许您声明每个限制的最小值，最大值和默认值。

在共享集群中过量使用资源通常是有益的，因为它可以使您的资源最大化。 但是，对群集的无限制访问可能会导致资源匮乏，从而导致性能下降和应用程序可用性损失。 如果pod的请求设置得太低，并且实际资源利用率超出了节点的容量，则该节点将开始经历CPU或内存压力。 发生这种情况时，可能会从节点重新启动和/或收回Pod.

为了防止这种情况的发生，您应该计划在多租户环境中对命名空间强加配额，以强制租户在集群上调度其pod时指定请求和限制。 通过限制Pod可以消耗的资源量，它还将减轻潜在的拒绝服务。

您还可以使用配额分配群集的资源，以与租户的支出保持一致。 这在KaaS场景中特别有用.

### 窗格优先级和抢占

当您想为不同的客户提供不同的服务质量（QoS）时，窗格优先级和抢占功能可能会很有用。 例如，使用Pod优先级，您可以将客户A的Pod配置为以高于客户B的优先级运行。当可用容量不足时，Kubelet将从客户B移出优先级较低的Pod，以容纳客户的高优先级Pod 答：这在SaaS环境中特别方便，在该环境中，愿意支付额外费用的客户可以获得更高的服务质量.

## 缓解控制

作为多租户环境的管理员，您的主要担心是阻止攻击者获得对基础主机的访问权限。 应该考虑采取以下控制措施来减轻这种风险: 

### Pod安全策略（PSP）

应该使用PSP来减少容器可以执行的操作并减少容器的特权，例如 以非root用户身份运行.

### 容器的沙盒执行环境

沙盒技术是一种使每个容器在其自己的隔离虚拟机中运行的技术。 执行Pod沙箱的技术包括[Firecracker](https://firecracker-microvm.github.io/) 和 Weave的 [Firekube](https://www.weave.works/blog/firekube-fast-and-secure-kubernetes-clusters-using-weave-ignite).

如果要在AWS上构建自己的自我管理的Kubernetes集群，则可以配置备用容器运行时，例如 [Kata Containers](https://github.com/kata-containers/documentation/wiki/Initial-release-of-Kata-Containers-with-Firecracker-support).

有关使Firecracker成为EKS支持的运行时的其他信息，请参阅
https://threadreaderapp.com/thread/1238496944684597248.html. 

### 开放政策代理（OPA）和Gatekeeper

[Gatekeeper](https://github.com/open-policy-agent/gatekeeper) 是Kubernetes准入控制器，用于强制执行[OPA]创建的策略(https://www.openpolicyagent.org/). 使用OPA，您可以创建一个策略，该策略在不同的实例上运行来自租户的Pod，或以比其他租户更高的优先级运行. 

还有一个实验性的 [OPA plugin for CoreDNS](https://github.com/coredns/coredns-opa) ，可让您使用OPA过滤/控制CoreDNS返回的记录. 

## 硬多租户
硬多租户可以通过为每个租户提供单独的群集来实现。 尽管这在租户之间提供了非常强的隔离性，但它有几个缺点。

首先，当您有很多租户时，这种方法很快就会变得昂贵。 您不仅必须支付每个集群的控制平面成本，而且您将无法在集群之间共享计算资源。 这最终将导致碎片化，其中群集的子集未得到充分利用，而其他群集则被过度利用。

其次，您可能需要购买或构建专用工具来管理所有这些集群。 随着时间的流逝，管理成百上千个集群可能变得太笨拙了。

最后，相对于创建名称空间而言，为每个租户创建集群将很慢。 但是，在高度管制的行业或需要严格隔离的SaaS环境中，可能需要硬租户方法. 

## 未来发展方向

Kubernetes社区已经意识到软多租户的当前缺点以及硬多租户的挑战。 [多租户特殊兴趣小组（SIG）](https://github.com/kubernetes-sigs/multi-tenancy)试图通过几个孵化项目来解决这些缺点，包括分层命名空间控制器（HNC）和虚拟集群 。

HNC提案（KEP）描述了一种通过\[policy\]对象继承在名称空间之间创建父子关系的方法以及租户管理员创建子名称空间的能力。

虚拟集群建议描述了一种机制，用于为集群中的每个租户创建单独的控制平面服务实例，包括API服务器，控制器管理器和调度程序（也称为“ Kubernetes上的Kubernetes”）。

## 多集群管理资源
+ [Rancher](https://rancher.com/products/rancher/)
+ [Kommander](https://d2iq.com/solutions/ksphere/kommander)
+ [Weave Flux](https://www.weave.works/oss/flux/)
+ [Banzai Cloud](https://banzaicloud.com/)
+ [Rafay](https://rafay.co/)
+ [Lens](https://github.com/lensapp/lens)
